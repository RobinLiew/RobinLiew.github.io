##第五章 类和对象##

-	1，面向对象概述
		类和对象的定义
		
	- 面向对象程序设计具有以下特点：
		
		- 封装性：封装是面向对象编程的核心思想，将对象的属性和行为封装起来，其载体就是类。
				类通常对客户隐藏其实现细节，这就是封装的思想。
		
		-	继承性：类和类之间的联系（子类和父类），增加代码的复用性，减少出错的几率。
				Java中将多继承改成了接口，降低了代码的复杂性。
		
		-	多态性：多态允许以统一的风格编写程序，以处理种类繁多的已存在的类及相关类。根据父类统一化的风格处理，可以实例化子类对象
				由于整个事件的处理只依赖于父类的方法，日后只要维护和调整父类的方法即可，降低了维护的难度。

-	2，类的基本知识
	
	-	成员变量：在Java中对象的属性也称为成员变量
	-	成员方法：在Java中使用成员方法对应于类对象的行为
	-	权限修饰符：private，protected，public
				
						    public		private		protected	  			
		-	本类        		可见 		可见		  可见
		-	同包其他类或子类	不可见		可见		  可见
		-	其他包的类或子类	不可见		不可见		  可见
		-	当声明类时不使用public、protected、private修饰符设置类的权限，则这个类预设为包存取范围，即只有一个包中的类可以调用这个类的成员变量或成员方法。
	
	-	局部变量：如果在成员方法内定义一个变量，那么这个变量被称为局部变量。局部变量在方法执行时创建，在方法执行结束时被销毁。
			 
		- 局部变量在使用时必须进行赋值操作或初始化，否则会出现编译错误。
		- 局部变量的有效范围：在互不嵌套的区域可以定义同名、同类型的的局部变量，在嵌套区域重复定义局部变量，编译器会报错。
	
	-	this关键字：在Java语言中规定使用this关键字来代表本类对象的引用，this关键字被隐式的用于引用对象的成员变量和方法。
				事实上，this引用的就是本类的一个对象
	
	-	构造方法：构造方法是一个与类同名的方法，对象的创建就是通过构造方法完成。每当类实例化一个对象时，类都会自动调用构造方法。
			  
		如果类中没有明确定义构造方法，编译器会自动创建一个不带参数的默认构造方法。（如果定义了，则不会默认设置无参的构造方法）
			 
			可以在无参构造方法中使用this关键字调用有参的构造方法，但需要注意的是只可以在无参构造方法中的第一句使用this调用有参构造方法。
	
	-	super关键字：
		-	1.调用父类的构造方法
				子类可以调用父类声明的构造方法。但是必须在子类的构造方法中使用super关键字来调用。
		-	2.操作被隐藏的成员变量和被覆盖的成员方法
				如果想在子类中操作父类中被隐藏的成员变量和被覆盖的成员方法，也可以使用super关键字。
	
	-	静态变量、常量和方法：
			
		-	被声明为static的变量、常量和方法被称为静态成员。一般使用“类名.静态成员”形式调用。
			-	静态数据与静态方法的作用通常是为了提供共享数据或方
			法，如数学计算公式等。静态成员同样遵循着public、private和protected修饰符的约束。
			
			-	在静态方法中不可以使用this关键字；
			
			-	在静态方法中不可以直接调用非静态方法。
			
			-	在Java中规定不能将方法体内中的局部变量声明为static的。
	
	-	类的主方法：主方法是类的入口点，它定义了程序从何处开始；主方法提供对程序流向的控制，Java编译器通过主方法来执行程序。
			
		主方法的语法：public static void main(String[] args){}
			
		- 主方法是静态的，所以如果直接在主方法中调用其他方法，则该方法必须也是静态的。
		- 主方法没有返回值。
		- 主方法的形参为数组。

-	3，对象
	-	对象的创建：在Java语言中通过new操作符创建对象。每实例化一个对象就会自动调用一次构造方法，实质上这个过程就是创建对象的过程。
		
		-	也就是说，可以在Java语言中使用new操作符调用构造方法创建对象。
		-	在Java语言中对象的初始化与创建是被捆绑在一起的。
		-	引用只是存放一个对象的内存地址，并非存放一个对象，严格地的说引用和对象是不同的。
	
	-	对象的比较：在Java语言中有两种对象的比较方式，分别为“==”运算符和equals()方法。
			
		-	equals用于比较两个对象引用所指的内容是否相等；String类中的该方法实际上是覆写了Object类中的该方法。
		-	“==”比较的是两个对象引用的地址是否相等。
	
	-	对象的销毁：其他语言中需要手动回收废弃的对象，但Java拥有一套完整的垃圾回收机制，垃圾回收器将自动回收无用的但占用内存的资源。
				
		-	被Java虚拟机视为垃圾的情况主要包括两种：
			-	对象引用超过其作用范围，这个对象将被视为垃圾。
			-	将对象赋值为null。
				
		-	垃圾回收器只回收由new操作符创建的对象，其他的由Java中的finalize()方法回收。
				
		-	由于垃圾回收器不受人为控制，具体执行时间也不确定，所以finalize()方法也就无法执行。为此，Java提供了System.gc()方法强制启动垃圾回收器。

##第六章 接口、继承与多态##

-	1，类的继承
	-	Object类：Java中所有的类都直接或间接继承了java.lang.Object类。Object是所有类的父类。
		
		-	Object类中主要包括euqals(),toString(),finalize()
		等方法
			
		-	Object中的几个重要的方法：
				
			-	getClass()方法：该方法是Object类定义的方法，它会返回对象执行时的Class实例，然后使用此实例调用其他方法。
				
			-	toString()方法：该方法的功能是将一个对象返回为字符串形式，它会返回一个String实例。
								在实际的应用中通常重写
			-	toString()方法，为对象提供一个特定的输出模式。
								当一个类转换为字符串或与字符串连接时，将自动调用重写toString()方法。
				
			-	equals()方法：equals()方法的默认实现是使用“==”运算符比较两个对象的应用地址，而不是比较对象的内容，
								所以要想正真做到比较两个对象的内容，需要在自定义类中重写equals()方法。
	
	-	对象类型的转换：主要包括向上转型和向下转型。
					
		-	向上转型：例，Object obj=new Person()；由于向上转型是从一个较具体的类到较抽象的类的转换，所以它总是安全的。
					
		-	向下转型：在做向下转型操作时，将特性范围小的对象转换为特性范围大的对象肯定会出现问题，所以这时需要告知编译器要做向下转型的操作。
		
		-	将父类对象强制转换为某个子类对象，这种方式称为显示类型转换。
		使用instanceof操作符判断对象类型：
				
			-	在程序执行向下转型的操作时，如果父类对象不是子类对象的实例（Object obj=new Person()），就会发生ClassCastException异常，所以在执行向下
				转型之前需要养成一个良好的习惯，就是判断父类对象是否为子类对象的实例。
				
			-	使用格式：父类对象名 instanceof 子类类型；返回值为布尔值。

-	2，方法的重载
	-	参数类型不同，构成重载
	-	参数个数不同，构成重载
	-	参数顺序不同，构成重载
	-	不定长方法的语法如下：
		
		返回值 方法名（参数数据类型... 参数名称）；在参数列表中使用“...”定义不定长参数，其实这个不定长参数就是一个数组。

-	3，多态
	
		利用多态可以使程序具有良好的扩展性，并可以对所有类对象进行通用处理。

-	4，抽象类与接口
	
	-	抽象类：
		-	abstract是定义抽象类的关键字
	
		-	使用abstract关键字定义的类称为抽象类，而使用这个关键字定义的方法称为抽象方法，抽象方法没有方法体，这个方法本身没有任何意义，除非它被重写。
	
		-	承载这个抽象方法的抽象类必须被继承，实际上抽象类除了被继承之外没有任何意义。
	
		-	如果声明一个抽象方法，就必须将承载这个抽象方法的类定义为抽象类，不可能在非抽象类中获取抽象方法。
	
	-	接口：
		-	接口是抽象类的延伸，可以将它看做是纯粹的抽象类，接口中的所有方法都没有方法体。
	
		-	接口使用interface关键字进行定义。
	
		-	在接口中定义的方法必须被定义为public或者abstract形式，其他修饰权限不被Java编译器认可，即使不将该方法声明为public形式，它也是public。
	
		-	在接口中定义的任何字段都自动是static和final的。
	
		-	Java中多继承的语法为：Class 类名 implements 接口1，接口2，... ，接口n
	
##第七章 类的高级特性##

-	1，Java类包
	-	Java中提供了一种管理类文件的机制，就是类包。类包名一般设定Internet为域名，避免了包名冲突。
	
	-	使用import关键字导入包，导入包时在包指定后加上“*”，这表示可以在程序中使用包中的所有类。
	
	-	可以使用import导入静态成员，语法：
		
		import static 静态成员；导入后，可以在主方法中直接使用这些静态成员。

-	2，final关键字
	-	final变量：由final定义的变量通常为常量，且final关键字定义的变量必须在声明时对其进行赋值操作。
		
		-	定义为final的数据无论是常量、对象还是数组，在主函数中都不可以被改变。
				
		-	一个被定义为final的对象只能指向唯一一个对象，不可以将它再指向其他对象，但一个对象本身的值却是可以改变的，要做到使一个常量真正做到不可更改，
				
		-	可以将常量声明为static final。
				
		-	Java中定义全局变量，通常使用public static final修饰，这样的常量只能在定义时被赋值。
	
	-	final方法：定义为final的方法不能被重写。
		
		-	将方法定义为final类型可以防止子类修改该类的定义与实现方式，同时定义为final的方法的执行效率要高于非final方法。
				
		-	如果一个父类的某个方法被设置为pivate修饰符，子类将无法访问该方法，自然无法覆盖，所以一个定义为private的方法隐式被指定为final类型，
				
		-	这样无须将一个定义为private的方法再定义为final类型。
	
	-	final类：定义为final的类不能被继承。
				
		-	如果将某个类设置为final形式，则类中的所有方法都被隐式设置为final形式，但final类中的成员变量可以被定义为final或非final形式。

-	3，内部类
	-	内部类可以分为成员内部类、局部内部类以及匿名类
	
	-	成员内部类:在一个类中使用内部类，可以在内部类中直接存取其所在类的私有成员变量。
				
		-	在内部类中可以随意使用外部类的成员方法以及成员变量，尽管这些类成员被修饰为private。
				
		-	内部类可以访问它的外部类成员，但内部类的成员只有在内部类的范围之内是可知的，不能被外部类使用。
				
		-	如果在外部类和非静态方法之外实例化内部类对象，需要使用外部类。
				
				
				例，OuterClass out=new OuterClass();//内部类的对象实例化操作必须在外部类的非静态方法中实现
					
				OuterClass.innerClass in=out.doit();//doit()方法中有return new innerClass();
					
				OuterClass.InnerClass in2=out.new innerClass();//也可以在外部类中实例化内部类。
	
	-	局部内部类：暂时先忽略。。。
	
	-	匿名内部类：匿名内部类的所有实现代码都需要在大括号之间进行编写。语法如下：
				
				return new A(){
					//内部类体
				}
				匿名内部类编译以后，会产生以“外部类名$序号”为名称的.class文件，序号以1~n排列，分别代表1~n个匿名内部类。
	
##第八章 String类##

-	1，创建字符串
	
	-	Java语言中字符串必须包含在一对双引号之内。
		
		-	String str=null；如果忽略null，表示str变量是未初始化的状态，否则表示声明的字符串的值等于null;
		
		-	String类的常用构造方法包括String(char[] a);String(char[],int offset,int length);等方法
	
		-	除了使用String类构造方法创建字符串变量外，还可以通过
		
		-	字符串常量的引用赋值给一个字符串变量。
		
		-	字符串的连接：
				
			-	Java中一句相连的字符串不能分开在两行中写。如果字符串太长，可以用“+”连接
				System.out.println("I like"+
				"Java");
	
			-	和其他数据类型的连接：会自动调用toString()方法，将其转换为字符串，然后参与连接。

-	2，字符串的操作
	
	-	获取字符串的信息：
					
		-	获取字符串长度：str.length();
					
		-	字符串查找：String类提供了两种查找字符串的方法，即indexOf()与lastIndexOf()方法。
					
		-	indexOf(String s);该方法返回字符串s在指定字符串中首次出现的索引位置。如果没有检索到s，该方法返回-1；
					
		-	lastIndexOf(String str);该方法用于返回指定字符串最后一次出现的索引位置。同样没有检索到，返回-1；
											如果该方法中的参数是空字符串“”（没有空格），返回的结果与调用该字符串length()方法返回的结果相同。
				
		-	获取指定索引位置的字符串：charAt(int index);
	获取子字符串：
					
		-	通过substring()方法可对字符串进行截取。
			
			-	substring(int beginIndex);该方法返回的是从指定的索引位置开始截取直到该字符串结尾的子串。
					
			-	subString(int beginIndex,int endIndex);该方法返回的是从某一索引位置开始截取至某一索引位置结束的子串。包含头，不包含尾。
	
	-	去除空格：trim返回字符串副本，忽略前导空格和尾部空格。		str.trim();
	
	-	字符串替换：replace()方法可实现将指定的字符或字符串替换成新的字符或字符串。
				
		-	语法：str.replace(char oldChar,char newChar);
				
			如果要替换的字符oldChar在字符串中重复出现多次，replace()方法会将所有oldChar全部替换成newChar。
	
	-	判断字符串的开始与结尾：startsWith()方法与endsWith()方法分别用于判断字符串是否以指定的内容开始或结束。这两个方法的返回值都为boolean类型。
		-	startsWith()该方法用于判断当前字符串对象的前缀是否是参数指定的字符串。
						
		-	endsWith()该方法用于判断当前字符串是否以给定的子字符串结束。
	
	-	判断字符串是否相等：使用equals()方法和equalsIgnoreCase()方法。
		
	-	按字典顺序比较两个字符串：compareTo()方法为按字典顺序比较两个字符串，该比较基于字符串中各个字符的Unicode值，按字典顺序将此String对象表示的字符序列
								
		-	与参数字符串所表示的字符序列进行比较。
		
		-	如果按字典顺序此String对象位于参数字符串之前，则比较结果为一负整数；
								
		-	如果按字典顺序此String对象位于参数字符串之后，则比较结果为一正整数；
								
		-	如果这两个字符串相等，则结果为0。
	
	-	字母大小写转换：str.toLowerCase()和str.toUpperCase()。
	
	-	字符串分割：使用split()方法可以使字符串按指定的分割字符或字符串对内容进行分割。
				
		-	split(String sign);其中sign为分割字符串的分隔符，也可以使用正则表达式。
				
		-	如果想定义多个分割符，可使用符号“|”。例如，“,|=”表示分隔符分别为","和"="。
				
		-	split(String sign,int limit);该方法可根据给定的分隔符对字符串进行拆分，并限定拆分的次数。
    
	-	格式化字符串：String类的静态方法用于创建格式化的字符串。format()方法有两种重载形式。
				
		-	format(String format,Object...args);该方法使用指定的格式字符串和参数返回一个格式化字符串，格式化后的新字符串使用本地默认的语言环境。
				
		-	format(Local l,String format,Object...args);local l为格式化过程中要应用的语言环境。如果l为null，则不进行本地化。
				
		-	可以实现日期格式化、时间格式化和格式化常见的日期时间组合
				
				例，Date date=new Date();
					String s=String.format("%te",date);//需要熟悉一些常用的日期格式化转换符。
				常规类型格式化可应用于任何参数类型。
	
		-	使用正则表达式：正则表达式通常用于判断语句中，用来检查某一字符串是否满足某一格式。
					
			-	例如，"\\d"表示数字0~9中的任何一个。
					
			- 在正则表达式中"."代表任何一个字符，因此在正则表达式中如果想要使用普通意义的点字符"."，必须使用转义字符"\"。
					
			- 邮箱地址的正则表达式："\\w+@\\w+(\\.\\w)*\\.\\w+"。
	
	-	StringBuffer和StringBuilder:
								
		-	StringBuffer:就是字符串缓冲区。用于存储数据的容器。
								
			特点：1，长度是可变的；2，可以存储不同类型的数据；3，最终要转成字符串进行使用；可以对字符串进行修改。
								
		-	1，添加：
				
				StringBuffer append(data);
				StringBuffer insert(index,data);
								
		-	2，删除：
				
				StringBuffer delete(start,end):包含头，不包含尾。
				StringBuffer deleteCharAt(int index):删除指定位置的元素 
		-	3，查找：
			
				char charAt(index);
				int indexOf(string);
				int lastIndexOf(string);
		
		-	4，修改：
				
				StringBuffer replace(start,end,string);
				void setCharAt(index,char);
				
		-	增删改查  C(create)U(update)R(read)D(delete) 
								
		-	StringBuider:jdk1.5后出现了和StringBuffer一模一样的对象，就是Stringbuider。
				
			-	StringBuffer是线程同步的，Stringbuilder是线程不同步的。
			-	所以StringBuffer通常用于多线程，Stringbuilder通常用于单线程，提高了效率。
	
##第九章 包装类和Math类##
	
-	Java.lang包中的Integer类、Long类和Short类，分别将基本类型int、long和short封装成类。
		
-	这些类都是Number的子类，区别就是封装不同的数据类型，其包含的方法基本相同。
		
			例，Integer number=new Integer("45");要以数值型String变量作为参数，否则会抛异常。
	
-	重点介绍Integer类中的parseInt()方法，该方法返回与调用该方法的数值字符串相应的整型值。
		
			toString();
			toBinaryString();
			toHexString();
			toOctalString();这些方法分别将值转换成十进制、二进制、十六进制和八进制的字符串。
		
-	其他的包装类还有Boolean、Byte、Character、Double、Float。
    
-	Math类：Java语言中提供了一个执行数学基本运算的Math类，该类包括了常用的数学运算方法，还提供一些常用的数学常量。方法基本上是静态的。
			
-	常用的数学运算方法：sin();exp();sqrt();等方法。
			
	-	取整函数的方法：主要包括ceil(),floor(),round()等方法。
			
	-	随机数：Java中主要提供了两种方式产生随机数，分别为Math()类的random()方法和Random类。
					
		-	Math.random()方法：默认生成大于等于0.0小于1.0的double型随机数。
					
		-	Random类：可以通过实例化一个Random对象创建一个随机数生成器。在Random类中提供了获取各种数据类型随机数的方法。